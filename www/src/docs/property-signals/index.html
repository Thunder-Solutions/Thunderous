<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="description" content="Documentation for the Thunderous library." />
		<title>Thunderous | Property Signals</title>
		<link rel="stylesheet" href="/global.css" />
		<link rel="favicon" href="/favicon.ico" />
	</head>
	<body>
		<th-doc-page>
			<th-page-header>Property Signals</th-page-header>
			<th-content-group>
				<th-text>
					In addition to attributes, there are also properties. Though often conflated, there is an important
					distinction: <em>attributes</em> are strings defined in HTML, and <em>properties</em> can be any type of data,
					strictly in JavaScript and completely invisible to HTML.
				</th-text>
				<th-text>
					Modern templating solutions often allow developers to assign properties via HTML attribute <em>syntax</em>,
					even though they are not actually attributes. While this distinction may seem trivial for those working with
					modern frameworks, it becomes much more relevant when defining custom elements that may be used in plain HTML.
				</th-text>
				<th-text>
					Thunderous supports properties for cases where strings are not sufficient. These are also reflected as signals
					<em>within</em> the component, but the <em>consumer</em> of the component will not directly interact with this
					signal. <th-code>myElement.count = 1</th-code> will update the internal signal.
				</th-text>

				<th-code-block lang="ts"><%= include('_code-snippets/property-signals.ejs') %></th-code-block>

				<th-text>
					There is also a way to sync attributes with properties, though it should be used deliberately, with caution.
					Since it requires some coercion to occur, it may introduce some performance overhead. It's best not to use
					this to parse JSON strings, for example.
				</th-text>

				<th-text>
					To use this feature, pass <th-code>attributesAsProperties</th-code> in the options. It accepts an array of
					<th-code>[propertyName, coerceFn]</th-code> pairs. For primitive types, you can use their constructors for
					coercion, like <th-code>['count', Number]</th-code>.
				</th-text>

				<th-code-block lang="ts"><%= include('_code-snippets/attributes-as-properties.ejs') %></th-code-block>

				<th-text>
					With the above snippet, <th-code>count</th-code> may be controlled by setting the attribute, like so:
				</th-text>

				<th-code-block lang="ts"><%= include('_code-snippets/attributes-as-properties-usage.ejs') %></th-code-block>

				<th-text> ...and the attribute will reflect changes made to the property as well: </th-text>

				<th-code-block lang="ts"><%= include('_code-snippets/attributes-as-properties-usage-2.ejs') %></th-code-block>

				<th-text> In both cases, the <th-code>count()</th-code> signal will be updated. </th-text>
			</th-content-group>
		</th-doc-page>
		<script type="module" src="/main.ts"></script>
	</body>
</html>
